# S式エージェントシステム - 技術レビューとロードマップ

## 現在のシステム概要

### 実装済み機能

#### コアアーキテクチャ
- **S式パーサー**: 適切なエラーハンドリング付きのS式解析
- **デュアル評価器**: 同期・非同期両対応の評価エンジン（並列実行対応）
- **LLM統合**: ローカルLLM（OpenAI互換API）によるS式生成
- **ツールレジストリ**: モジュラーなツールシステムと自動登録

#### 主要機能

1. **数学処理**:
   - SymPy直接統合による記号数学演算
   - 段階的数学解法エンジン（部分積分の詳細説明など）
   - 微分、積分、因数分解、方程式求解対応

2. **Human-in-the-Loopシステム**:
   - 事前情報収集（S式生成前の不足情報分析）
   - ユーザーインタラクションツール（ask_user, collect_info, suggest_and_confirm）
   - 文脈に応じた条件付き質問
   - エージェントの推測・提案とユーザー確認

3. **タスクフロー管理**:
   - 順次実行（seq）による依存タスク処理
   - 並列実行（par）による独立タスク処理
   - 適切な依存関係分析（例：料理の材料準備→調理）
   - let式による文脈対応変数束縛

4. **CLIインターフェース**:
   - 自然言語からの自動S式生成
   - 生成前の情報収集
   - パース・実行ワークフロー
   - デバッグ機能とユーザーフレンドリーなエラーハンドリング

#### 現在のツールセット
- **数学**: math（基本演算）, step_math（詳細解法）
- **ユーザーインタラクション**: ask_user, collect_info, conditional_ask, suggest_and_confirm
- **基本**: notify, calc, search, db-query

#### ワークフロー例
```
ユーザー: "2泊3日の旅行プランを作って"
→ システムが不足情報を分析（行き先、予算）
→ ユーザーから必要情報を収集
→ 収集データを使ってS式生成:
   (seq
     (ask_user "destination" "travel_dest" "required")
     (search "travel plan " + $travel_dest + " 2 nights")
     (notify "Travel plan created"))
→ 適切な依存管理で実行
```

---

## O3による技術レビュー結果

### 1. アーキテクチャ評価

#### ✅ 強み
- 関心事の明確な分離：パーサー → 評価器 → ツール層 → CLI
- 同期/非同期デュアル評価器による環境間ポータビリティ
- レジストリパターンによるツールの疎結合

#### ⚠️ 改善が必要な箇所
- **実行エンジン**: 現在の木構造解釈器は大規模・深いネスト時にコールスタック問題
  - **推奨**: S式をDAGにコンパイルしてスケジューラーで実行
- **状態ストア不在**: 長時間実行エージェント用の永続化が必要
- **バージョニング**: ツールとAST両方にセマンティックバージョニング
- **可観測性**: OpenTelemetryスパンやJSONログによる計装

### 2. S式設計評価

#### ✅ 現在の設計は効果的
- 木構造プラン表現に最適

#### 🔧 不足している構文
- **try/catch**: `(handle err-sym form fallback-form)` - ツール失敗時の分岐
- **while/loop**: 最大反復数付き - 再試行・反復改善タスク用
- **メタマクロ機能**: プラン構築時の展開でドメイン固有糖衣構文

### 3. ツールシステムのスケーラビリティ

#### 📋 採用すべきベストプラクティス
- **機能インターフェース**: 各ツールがI/Oスキーマ + 副作用フラグを宣言
- **依存性注入**: グローバル変数ではなくプロバイダーオブジェクト経由
- **分離戦略**: 重いツール・信頼できないツールは別プロセス/コンテナで実行

### 4. Human-in-the-Loop最適化

#### 🧠 より賢くする方法
- **信頼度ゲーティング**: LLMが埋めるスロットに信頼スコア、閾値以下で質問
- **マルチターンフォーム**: 認知負荷許容時は複数スロットを一度に収集
- **能動的明確化リスト**: 曖昧なエンティティスタックを早期解決
- **適応温度**: 事実スロット要求時はLLM創造性を下げる

### 5. パフォーマンス・スケーラビリティ

#### 🚨 主要なボトルネック
- **LLMレイテンシ**: `(par ...)`内の独立LLM呼び出し並列化
- **Python単一スレッドSymPy**: マルチプロセシングかコンパイル版SymPy使用
- **レジストリ検索**: 数千ツール時はトライやハッシュでインデックス化
- **プランナー爆発**: LLMの長大プラン生成をトークン予算で制限

### 6. セキュリティ考慮事項

#### 🔒 サンドボックス除去で露出したリスク
- **DoS**: SymPyの巨大式生成 → タイムアウト・再帰深度制限・OS級メモリ制限
- **コード注入**: ユーザー入力のS式への直接補間 → サニタイズ・エスケープ
- **プロンプト注入**: LLMのS式生成時 → 許可リスト検証・未知ノード拒否
- **シークレット漏洩**: APIキーをプラン文に含めない → 環境変数・暗号化ストア

### 7. エラーハンドリング

#### 📊 本番環境の多層戦略
- **構造化例外**: 評価器内で `{type, message, stack, partial-state}` に変換
- **自動再試行**: 一時的ツール失敗（HTTP 5xx、タイムアウト）に指数バックオフ
- **補償フック**: 後段失敗時の前段副作用ロールバック
- **レジューム トークン**: クラッシュ時の `(resume <token>)` による再開

### 8. 推奨される次期ツール（優先順）

1. **ファイルI/O** (read_file, write_file, list_dir) - レポート生成・コード記述
2. **HTTP/GraphQL APIコラー** - SaaSバックエンド統合  
3. **ヘッドレスブラウザスクレーパー** (playwright) - API不在時の構造化データ抽出
4. **ベクターストア検索** (embed_and_search) - ドキュメント・コード用RAGワークフロー
5. **カレンダー/メール送信** - 生産性エージェント用フルタスク自動化
6. **データフレーム操作** (pandas-tool) - エージェント内アナリティクス
7. **シェルコマンドツール** (分離dockerコンテナ内) - パワーユーザー・DevOpsタスク
8. **PDF/Officeドキュメント処理** - ビジネス用途

---

## 90日間実装ロードマップ

### 週1-2: 基盤強化
- [ ] 正式AST Schema（JSON-schema）+ LLM出力ゲート検証器
- [ ] try/catch、while構文の導入

### 週3-4: 実行基盤改善  
- [ ] 評価器をDAG実行器にリファクタリング + OpenTelemetryトレース統合
- [ ] ツールごとのメタデータ実装（副作用、コスト、バージョン）

### 週5-6: セキュリティ・ツール拡張
- [ ] SymPy重いジョブ用のサンドボックス化ワーカープール（リソース制限付き）
- [ ] ファイルI/O・HTTP APIツールの機能フラグ付き実装

### 週7-8: セキュリティ強化・UX改善
- [ ] セキュリティ強化：入力エスケープ、シークレット管理、プロンプトインジェクション防御
- [ ] Human-in-the-loopレイヤーでの信頼度ゲート質問戦略

### 週9-12: 本格運用準備
- [ ] 永続状態ストア + レジュームトークン
- [ ] ヘッドレスブラウザスクレーパーツール + 基本ベクターストア検索
- [ ] ~1,000並列エージェント実行での負荷テスト + スケジューラー・キャッシング調整

---

## まとめ

**現在の評価**: 機能的プロトタイプから本格的なエージェントプラットフォームへの移行準備完了

**次のステップ**: 実用的なツール（ファイルI/O、HTTP API）実装から着手し、段階的にセキュリティ・パフォーマンス・可観測性を強化

**目標**: 安全で拡張可能な本番レディエージェントプラットフォーム